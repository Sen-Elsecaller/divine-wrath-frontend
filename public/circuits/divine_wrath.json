{"noir_version":"1.0.0-beta.19+11c71e40895a37aacb7501db45ece4890dc062cc","hash":"8778726907418972733","abi":{"parameters":[{"name":"position","type":{"kind":"field"},"visibility":"private"},{"name":"claim_type","type":{"kind":"field"},"visibility":"public"},{"name":"claim_value","type":{"kind":"field"},"visibility":"public"},{"name":"expected_result","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"6337041431562560858":{"error_kind":"string","string":"Position must be <= 9"},"6690422623928667102":{"error_kind":"string","string":"Position must be >= 1"},"8922204073065721053":{"error_kind":"string","string":"Claim verification failed"}}},"bytecode":"H4sIAAAAAAAA/81bW1NTVxTOSUSiiAhyUYoKoh5AEBDEG4KEiyA3BZGAVJtCqkdCEkNgyvTp/IOTE3p/cYaLM7adsS+dttNHHp2h06d2hnbGt05nOm0f2sfSgJ4ACbC/fbIXlac9m3X2un1rrb32zrbpoQ9nx1yKd3TJ8oH6mSOgeDzK/UaXxzNt0dX5XsV73+MOayF9Id+y/Z9kYZJY1hbUWMTSS/Zjfo97lzFIAr6zSOozh8c1POrwvdsy4R1eUUWd62noutasq0/6laDXPT6+6/k/AFWSXX3aMD7uDgQH3QFfWAsjRojQVIx0BV5UPi7++kbzV6rqfLOo6tfWqW/8ocYXf4f/WF6WdjFo/owslAQYc4NwOrAownh3hDGDBjDd7oiBN4BJCm0EE1NUthghAxbJGCzWmysUBkRIXrEpS4pkABR2NjN+6ewhQDo7J4xWOLO0SbJrwKrbep/Jgs0g6v295rzP+iBprwZ4bduEmXCMS3vMJcwUY7BPVMLct0kqZKoHpMIUYJ19gJk2CIfYPoUTMqv5lfVFEsA4FUAV2x+p9sRqdarQWm2xRaG33xikiYLe/mSAKM3K7600wFsHhKhwwMq/kUhlR8+/+wEN0nhz9WsDpXRjkCEKSukIlDJMQCkDcMRBISocJIJSOqBBBnXZlzjKfiZN2ZcyEUGzTGzomJyzNOpQtVJ1aNnGIEdUqGZDHVqOiQ7NCmxLsoFoyKHo0BDGh4R0aIcS7dCyOTq0wzQdWvZhpEM7DIAil6BDy85FOrRcgg4tJ1fjBScSOch2IwegyaOuI3kcdeQITR3JO4IIepSgjuQd1XagTrPEjtr3GFGdPoak02OAMvkUtTwfyaD5FEGaIShIC6hBVMARpMdpQFRwHBG0kAAgBYWaibzPBFQhArsTBJbMOopwPvk/J6bI1m45iqlTRInplM7eYC6fApSRKRKTHAKkkylOjWUkYcsATREgHXv/W5TgCRoihaljj2JjUIIJIgsxRzFyNFJi4vBBBmhKAK+fFqLmaSs3cOUiJLXd5QwZPcw+k5GLgZwvlyAgucubeV+bcCg1BmU7GQ6lSDiUEYVDGYC3M0LUPGPlB2UpAsoyUaDkbn2FlZlyIRYuT7DMlFPFVYUxqNzJuKpA4qqSKK4qAa+fFaLmWRNlphwpM8MUZaYCiehKBCTD1GWGLByqjEH1ToZDFRIO1UThUA3g7ZwQNc+ZKDNVCCiryUGJVJNiQIgK9m2KuauXGmNwXtTVSw1CdD7m5mValJ2A25kagNd5wN7cUVUMMK4AaC4QnP3INTqYF1grXSTYll24iFS3S0KyzSUTv1USAc2VdS4T2E6uQWxXS8D5ci3C+YoQr12xJ5aEy5CKR5WE64xBvagkXIcQ1ZtIwpCdgCRcB/Cqp0jCSHeMbG2uUiThOlFJuIEgnK82IOHsEBLODhNJWAQ0V9ZppEjCdYjtmgg4NzYhnJuFeK3Zzi3exUuIeA8IDFN7BeGsmLlkZS3aAiD1AUCj8P7EnPdCrIXjkvUazYVYyzVE0FaCy66WVo0Adg0OBHYPCTg3NSOcRykA3wa48CFAgwiXEODbOAB/nQbwbdcRQdsJAN/WrlE4v0NctrOwhEvI+R0czu+kcX5HJyJoF4HzO7pInN8tLvJpS103h/Nv0Di/+wYi6E0C53ffpCh1re1Iwekh4Nx1E+HcS9DC9fQiTWgPQNMLaHCLolW5hdiujzdZiLpXvc0ZeDqgcn4hQHTiJGKXfuorLJvQK6x1h1BOYzAg6hDKCT3CGDDxCMMGnDA5AW8NUKAYYTy4IOIRxmCijzCcC/gjjDs0jzCcd5BHGHcAUAwRPMJwDiGPMIYI0vDAEG9JRjKd3AcQ3e4PiYmdkCUsWW3aJ7o62zCsBFL0xaGf5N9/VNt/0V5NpemL/X99+em9CycHjal0ffGN79zf1y/9tmRM1cZPtcdPvRU/NRI/5Ymf8sdPPX9fX3zvhz19Jx6X/hwJ+m9HlIB7OKhMuu8p3qD7vjtw79GEL6i4vcGP1LlGn3c8GFbnm1aJ9qpP2l7SzPRVnWUayRr7fQrf9xb185XQH3EFXY0+/1R0GcuaPNGFv3AoXldgqkVxe0a6/dPGP6xPXzFsUibjPpe2+kqa6ZzwRJcAyHsn3t5k9ZlO36QeN29VZ3uDPn9IXxPeUEd/tt4ZkxH0fxxrwiw+E0qx32cKdkHW2sIxnKxzq3YCWGxhVtt886MJl2d8EwvOX58Y87e9EzWhzR7LXQK5b+lUy8w6yEhrMsQ4LzNqiP8AKvyt5TBIAAA=","debug_symbols":"pZfBbtswDIbfxeccREoUpb3KMBRp6xYBgrRIkwJD0XcfaZJqd8hh2kXfnzj6YFGmY38sj+v99fnucHp6eVt+/PxY7s+H4/HwfHd8edhfDi8n+fbjc7fEx7vLeV3lq+XbcZn1uj+vp8vy43Q9HnfL+/543X709ro/bbzsz3I07Zb19CgU4dPhuGr63H3NTrenAlTy2QDch4BgytDKjAGxhAFLnjFUbmGorc0ZeBj61DlwHnVgmfbvBkyMbsDUeMYAqYcBsM4Z8H8NBMNAOGPAOgzIU+eAfRgy0IwhlzQMZWo3C429KDzTF0h5GKje7E2g2wpZRTSGrIInFTwUiHOKAkNBdU7BdSgaTSpoKHqaUtDor0xY5hRt1IL6pKKPHakwt5CKaShynlPULwVPKr42tba5C7z2sSMMc1dn66NHOsCUosNYSMc+eRZjU3ue29Rey1DwXLP3hkPRafIs8pdiqtlLGnetksrUHyG3KAW2NPUHwHzT8Es+7R8O578e5pYki9otsI24jXkbyzbSNtZt5G1s29htlkyWwgMYZLrUELKhGMggCjkxYINIpJDQN2AygAEN2SAWuUaRDNXAhmboG7JY5FLMYECDWGRPcjGQoRrY0Ax9Q0kGMKBBLNKupRjIUA1aFS1Xc3YjaV2lKAROdGan1lcKQ+TUGktpiJ3NqT5ZXk1O9cnKKjqzszjJWZ3sVJ+spXYjJyc40Zmd6pP1MTmrPt4J2dmc3diSE5zozPpAJSxOclYnO5tTfVKfnpzgRKf6pF69OMlZneqTuvXm7EZIKYIa9epLGCFHKBHUWjXUCByhRVAz69WfIkAEjKDmpqFEoAg1AkdoEdTctaFSBIiAEXKEEkE7TZtSu8QCR2gRxJy1VbVbLEAEjKD9q4XSrrFAEardAUF7x0KLoGYN2kEWIAJGyBFKBIpQI3CEFkHNekN+358P+/vj6u+gT9fTw7dX0svv1zgSL62v55eH9fF6XvWOtx2Te+Af","file_map":{"51":{"source":"// Divine Wrath - ZK Circuit para verificar claims de posicion\r\n//\r\n// El mortal tiene una posicion SECRETA (1-9) en un grid 3x3\r\n// El mortal hace un CLAIM publico sobre su posicion\r\n// Este circuito PRUEBA que el claim es verdadero sin revelar la posicion\r\n\r\n// ============================================================\r\n// TIPOS DE CLAIM:\r\n// 0 = row      -> \"Estoy en la fila X\"\r\n// 1 = column   -> \"Estoy en la columna X\"\r\n// 2 = adjacent -> \"Estoy adyacente a la celda X\"\r\n// ============================================================\r\n\r\nfn main(\r\n    // --- INPUTS PRIVADOS (solo el mortal los conoce) ---\r\n    position: Field,          // Posicion secreta del mortal (1-9)\r\n\r\n    // --- INPUTS PUBLICOS (todos los ven, incluido el God) ---\r\n    claim_type: pub Field,    // Tipo de claim (0=row, 1=col, 2=adj)\r\n    claim_value: pub Field,   // Valor del claim (fila/col/celda)\r\n    expected_result: pub Field // Resultado esperado (0=false, 1=true)\r\n) {\r\n    // ========================================================\r\n    // PASO 1: Validar que la posicion es valida (1-9)\r\n    // ========================================================\r\n    assert(position as u8 >= 1, \"Position must be >= 1\");\r\n    assert(position as u8 <= 9, \"Position must be <= 9\");\r\n\r\n    // ========================================================\r\n    // PASO 2: Calcular fila y columna de la posicion\r\n    // ========================================================\r\n    // Grid:  1 2 3    Filas: 0 0 0    Columnas: 0 1 2\r\n    //        4 5 6           1 1 1              0 1 2\r\n    //        7 8 9           2 2 2              0 1 2\r\n\r\n    let pos_u8 = position as u8;\r\n    let row = (pos_u8 - 1) / 3;      // Fila (0, 1, o 2)\r\n    let col = (pos_u8 - 1) % 3;      // Columna (0, 1, o 2)\r\n\r\n    // ========================================================\r\n    // PASO 3: Evaluar el claim segun su tipo\r\n    // ========================================================\r\n    let mut result: u8 = 0;\r\n\r\n    // --- CLAIM TIPO 0: Row ---\r\n    // \"Estoy en la fila claim_value\"\r\n    if claim_type == 0 {\r\n        if row == claim_value as u8 {\r\n            result = 1;\r\n        }\r\n    }\r\n\r\n    // --- CLAIM TIPO 1: Column ---\r\n    // \"Estoy en la columna claim_value\"\r\n    if claim_type == 1 {\r\n        if col == claim_value as u8 {\r\n            result = 1;\r\n        }\r\n    }\r\n\r\n    // --- CLAIM TIPO 2: Adjacent ---\r\n    // \"Estoy adyacente a la celda claim_value\"\r\n    if claim_type == 2 {\r\n        let other_pos = claim_value as u8;\r\n        result = is_adjacent(pos_u8, other_pos);\r\n    }\r\n\r\n    // ========================================================\r\n    // PASO 4: Verificar que el resultado coincide\r\n    // ========================================================\r\n    assert(result == expected_result as u8, \"Claim verification failed\");\r\n}\r\n\r\n// ============================================================\r\n// FUNCION AUXILIAR: Verificar adyacencia\r\n// ============================================================\r\n// Dos celdas son adyacentes si comparten un lado (no diagonal)\r\n//\r\n// Adyacencias:\r\n// 1 <-> 2, 4          5 <-> 2, 4, 6, 8 (centro, 4 vecinos)\r\n// 2 <-> 1, 3, 5       6 <-> 3, 5, 9\r\n// 3 <-> 2, 6          7 <-> 4, 8\r\n// 4 <-> 1, 5, 7       8 <-> 5, 7, 9\r\n//                     9 <-> 6, 8\r\n\r\nfn is_adjacent(pos_a: u8, pos_b: u8) -> u8 {\r\n    // Calcular filas y columnas\r\n    let row_a = (pos_a - 1) / 3;\r\n    let col_a = (pos_a - 1) % 3;\r\n    let row_b = (pos_b - 1) / 3;\r\n    let col_b = (pos_b - 1) % 3;\r\n\r\n    // Diferencias absolutas\r\n    let row_diff = if row_a > row_b { row_a - row_b } else { row_b - row_a };\r\n    let col_diff = if col_a > col_b { col_a - col_b } else { col_b - col_a };\r\n\r\n    // Adyacente = exactamente 1 celda de diferencia en UNA dimension\r\n    // (row_diff == 1 AND col_diff == 0) OR (row_diff == 0 AND col_diff == 1)\r\n    let adjacent_vertical = (row_diff == 1) & (col_diff == 0);\r\n    let adjacent_horizontal = (row_diff == 0) & (col_diff == 1);\r\n\r\n    if adjacent_vertical | adjacent_horizontal {\r\n        1\r\n    } else {\r\n        0\r\n    }\r\n}\r\n\r\n// ============================================================\r\n// TESTS\r\n// ============================================================\r\n\r\n#[test]\r\nfn test_row_claim_true() {\r\n    // Posicion 5 esta en fila 1\r\n    // Claim: \"Estoy en fila 1\" -> true\r\n    main(5, 0, 1, 1);\r\n}\r\n\r\n#[test]\r\nfn test_row_claim_false() {\r\n    // Posicion 5 esta en fila 1, no en fila 0\r\n    // Claim: \"Estoy en fila 0\" -> false\r\n    main(5, 0, 0, 0);\r\n}\r\n\r\n#[test]\r\nfn test_column_claim_true() {\r\n    // Posicion 5 esta en columna 1\r\n    // Claim: \"Estoy en columna 1\" -> true\r\n    main(5, 1, 1, 1);\r\n}\r\n\r\n#[test]\r\nfn test_column_claim_false() {\r\n    // Posicion 5 esta en columna 1, no en columna 2\r\n    // Claim: \"Estoy en columna 2\" -> false\r\n    main(5, 1, 2, 0);\r\n}\r\n\r\n#[test]\r\nfn test_adjacent_claim_true() {\r\n    // Posicion 5 es adyacente a 2, 4, 6, 8\r\n    // Claim: \"Estoy adyacente a celda 2\" -> true\r\n    main(5, 2, 2, 1);\r\n}\r\n\r\n#[test]\r\nfn test_adjacent_claim_false() {\r\n    // Posicion 5 NO es adyacente a 1 (diagonal)\r\n    // Claim: \"Estoy adyacente a celda 1\" -> false\r\n    main(5, 2, 1, 0);\r\n}\r\n\r\n#[test]\r\nfn test_corner_adjacent() {\r\n    // Posicion 1 es adyacente a 2 y 4 solamente\r\n    main(1, 2, 2, 1);  // Adyacente a 2 -> true\r\n    main(1, 2, 4, 1);  // Adyacente a 4 -> true\r\n}\r\n\r\n#[test]\r\nfn test_corner_not_adjacent_diagonal() {\r\n    // Posicion 1 NO es adyacente a 5 (diagonal)\r\n    main(1, 2, 5, 0);\r\n}\r\n","path":"/home/sen/projects/divine-wrath-circuits/src/main.nr"}}}